# Key-Value (Redis) #

Redis is an open-source (BSD License) in-memory key-value store supporting atomic operations.

Various features:
- Built-in replication
- Lua scripting 
- LRU eviction
- TTL
- Automatic failover
- Transactions
- On-disk persistence
  - Multiple levels
    - Dump dataset to disk on interval, and/or
    - Append each command to a log, or
    - Disable persistence entirely
- Atomic operations
  - Append to string
  - Increment value in hash
  - Push element to list
  - Compute set intersection, union, difference
  - Get highest-ranking member in sorted set
- Outstanding performance
  - In-memory
  - Basically giant hash table that has bells and whistles

## Supported Data Structures ##

- String
- Hash
- List
- Set
- Sorted set
- Bitmap
- Bitfield
- Stream
- Hyperloglog
  - Maintain counts of obscene amounts of items with extreme space efficiency
- Geospatial index
  - Latitude & longitude coordinates
  - Comes with special calculations like finding the distance between two
    cities

## Data Model ##

In-memory data structure key-value store that persists data on-disk.

- Key: string
- Value: any of the above listed data structures

### Persistence ###

#### Snapshot (RDB) ####

Saves snapshot of dataset at user-defined intervals in a RDB file. Whenever
it’s time to perform a snapshot, a new process is forked from the parent
process and creates the RDB file. By forking, it allows the main redis
instance to keep accepting requests.

#### Append Only File (AOF) ####

AOF persistence logs every write operation to a single log file. Because the
file is only appended to, the original dataset can be rebuilt by executing
each write in the log file.

## Scaling and Replication ##

Horizontal scaling is achieved by using Redis Cluster (fancy sharding):
- Clusters are presumably really easy to set up because the data is schemaless
- Data is automaticaly sharded between Redis nodes in the cluster
- The cluster is still available during network partitions

## Consistency vs. Availability ##

Depending on you use Redis, there are 3 different models for consistency and availability.

### Single Instance with Persistence ###

In the context of a single Redis instance, there are no other nodes to be
consistent with. Instead, we will consider the data integrity on the single
instance.

If you use AOF, you get near-perfect data integrity.  
If you use RDB, you get variable data integrity.  
- It’s possible for data to be written in-memory and for the server to then
  crash, before it has a chance to be persisted to disk. It’s variable because
  the user defines the interval at which the snapshots are saved.

### Redis Cluster with Persistence ###

During network partitions, the cluster is still highly available. The
consistency within a cluster is lower, however, due to asyncronous data
replication. Redis Clusters use eventual consistency.

### Multiple Cache Instances ###

When using Redis purely for caching (no data persistence), Redis caches suffer
from the same availability and consistency issues that any caching system
would.

## Use Cases ##

- Cache
  - Session cache
    - Makes smart load balancers to app servers less important for user
      sessions
  - Full page cache (FPC)
    - A cache of a full HTML page generated by the app server
    - Ex. wordpress plugin: WP Redis
  - Other caches
    - Really flexible because of variety of supported data types
- Queues/buffers
  - Message queues for background jobs
    - Look at Workerholic
- Pub/sub
  - Publisher publishes message
    - Message has classes/categories/channels
  - Subscriber receives messages
    - Only if subscribed to class/category/channel
  - Don’t have to know each other or directly communicate
  - Examples:
    - Publishing to mailing list
    - Following hashtags on Instagram or Twitter
- Set calculations
  - Ex. quickly calculate all friends that are online
- Recommendation engine
  - Personalized recommendations often need set operations to be executed very
    quickly, provided by these built-in operations:
    - Intersection
    - Union
    - Set difference
  - Sets and sorted sets are built-in data types
  - Because Redis is in-memory, super high throughput and sub-millisecond latency
- Managing distributed locks
  - Ex. Ticketmaster: locking a ticket while your payment is processed
    - Prevents double-purchase of one ticket
    - Lock is released if payment rejected
    - Transaction is completed if payment accepted
- Leaderboards/counting
  - In-memory with atomic increment/decrement operations
  - Fast, real-time
- Shared state between processes

Other small use cases:
- Tag clouds
  - Natural Language Processing?
- Circular log buffers

## Drawbacks/Shortcomings ##

- No hard schema to enforce data integrity
- Limited query/analytics potential compared to RDBMS
  - Because data is schemaless and wide-ranging
- Depending on how you configure persistence, the data may be ephemeral
- Not as mature
- Size of data store is limited to RAM
  - Almost forced to horizontally scale if used as persistent database
- Single-threaded
